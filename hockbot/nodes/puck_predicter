#!/usr/bin/env python
import numpy as np

import rospy
from hockbot.msg import PointArray
from hockbot.msg import PositionVelocityStamped
from hockbot.puck_dynamics import PuckDynamics
from geometry_msgs.msg import PointStamped
from geometry_msgs.msg import Vector3Stamped


class PuckPredicter(object):

    def __init__(self):
        self._traj_publisher = rospy.Publisher(
            '/puck_predicter/visualization/trajectory',
            PointArray,
            queue_size=1)

        self._pos_vel_publisher = rospy.Publisher(
            '/puck_predicter/positionvelocity',
            PositionVelocityStamped,
            queue_size=1)

        self._time_ref = rospy.wait_for_message(
            '/detector/puck',
            PointStamped).header.stamp

        self._dynamics = PuckDynamics(self._time_ref)

        self._puck_sub = rospy.Subscriber(
            '/detector/puck',
            PointStamped,
            self._puck_sub_cb
            )

        self._timer_cb = rospy.Timer(
            rospy.Duration(0.1),
            self._pub_traj)

    def _puck_sub_cb(self, msg):
        '''
        Puck position receive callback. Immediately publish position and velocity of puck
        '''
        self._time = (msg.header.stamp - self._time_ref).to_sec()
        self._dynamics.add_point(msg)
        posvel = PositionVelocityStamped()
        posvel.header = msg.header
        posvel.position.x = self._dynamics.position[0]
        posvel.position.y = self._dynamics.position[1]
        posvel.velocity.x = self._dynamics.velocity[0]
        posvel.velocity.y = self._dynamics.velocity[1]
        self._pos_vel_publisher.publish(posvel)


    def _pub_traj(self, _):
        point_array = PointArray()
        point_array.points = [self._dynamics.predict_position(t) for t in np.linspace(self._time, self._time+1.0, num=10)]
        self._traj_publisher.publish(point_array)

def main():
    rospy.init_node('puck_predicter')
    predicter = PuckPredicter()
    rospy.spin()


if __name__ == '__main__':
    main()